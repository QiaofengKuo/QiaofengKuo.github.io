<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奔跑の蚂蚁</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-01T18:28:19.140Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>北乔峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关系类型字段</title>
    <link href="http://yoursite.com/2019/11/02/%E5%85%B3%E7%B3%BB%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5/"/>
    <id>http://yoursite.com/2019/11/02/关系类型字段/</id>
    <published>2019-11-01T18:25:20.000Z</published>
    <updated>2019-11-01T18:28:19.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><a id="more"></a><h1 id="关系类型字段"><a href="#关系类型字段" class="headerlink" title="关系类型字段"></a>关系类型字段</h1><h2 id="多对一（ForeignKey）"><a href="#多对一（ForeignKey）" class="headerlink" title="多对一（ForeignKey）"></a><strong>多对一（ForeignKey）</strong></h2><p>多对一的关系，通常被称为外键。外键字段类的定义如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForeignKey</span><span class="hljs-params">(to, on_delete, **options)</span>[<span class="hljs-title">source</span>]</span></span><br></pre></td></tr></table></figure><p>外键需要两个位置参数，一个是关联的模型，另一个是on_delete选项。实际上，在目前版本中，ondelete选项也可以不设置，但Django极力反对如此，因此在Django2.0版本后，该选项会设置为必填。</p><p><strong>外键要定义在‘多’的一方！</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="hljs-string">'Manufacturer'</span>,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br><span class="line">    <span class="hljs-comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manufacturer</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># ...</span></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面的例子中，每辆车都会有一个生产工厂，一个工厂可以生产N辆车，于是用一个外键字段manufacturer表示，并放在Car模型中。注意，此manufacturer非彼Manufacturer模型类，它是一个字段的名称。在Django的模型定义中，经常出现类似的英文单词大小写不同，一定要注意区分！</p><p>如果要关联的对象在另外一个app中，可以显式的指出。下例假设Manufacturer模型存在于production这个app中，则Car模型的定义如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="hljs-string">'production.Manufacturer'</span>,      <span class="hljs-comment"># 关键在这里！！</span></span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>如果要创建一个递归的外键，也就是自己关联自己的的外键，使用下面的方法：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.ForeignKey(<span class="hljs-string">'self'</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>核心在于‘self’这个引用。什么时候需要自己引用自己的外键呢？典型的例子就是评论系统！一条评论可以被很多人继续评论，如下所示：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="hljs-number">128</span>)</span><br><span class="line">    text = models.TextField()</span><br><span class="line">    parent_comment = models.ForeignKey(<span class="hljs-string">'self'</span>, on_delete=models.CASCADE)</span><br><span class="line">    <span class="hljs-comment"># .....</span></span><br></pre></td></tr></table></figure><p>注意上面的外键字段定义的是父评论，而不是子评论。为什么呢？因为外键要放在‘多’的一方！</p><p>在实际的数据库后台，Django会为每一个外键添加<code>_id</code>后缀，并以此创建数据表里的一列。在上面的工厂与车的例子中，Car模型对应的数据表中，会有一列叫做<code>manufacturer_id</code>。但实际上，在Django代码中你不需要使用这个列名，除非你书写原生的SQL语句，一般我们都直接使用字段名<code>manufacturer</code>。</p><p>关系字段的定义还有个小坑。在后面我们会讲到的<code>verbose_name</code>参数用于设置字段的别名。很多情况下，为了方便，我们都会设置这么个值，并且作为字段的第一位置参数。但是对于关系字段，其第一位置参数永远是关系对象，不能是<code>verbose_name</code>，一定要注意！</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h3><p>外键还有一些重要的参数，说明如下：<br><strong>on_delete</strong><br><strong>注意：这个参数在Django2.0之后，不可以省略了，需要显式的指定！这也是除了路由编写方式外，Django2和Django1.x最大的不同点之一！</strong></p><p>当一个被外键关联的对象被删除时，Django将模仿<code>on_delete</code>参数定义的SQL约束执行相应操作。比如，你有一个可为空的外键，并且你想让它在关联的对象被删除时，自动设为<code>null</code>，可以如下定义：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = models.ForeignKey(</span><br><span class="line">    User,</span><br><span class="line">    models.SET_NULL,</span><br><span class="line">    blank=<span class="hljs-literal">True</span>,</span><br><span class="line">    null=<span class="hljs-literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该参数可选的值都内置在<code>django.db.models</code>中，包括：</p><ul><li><code>CASCADE：</code>模拟SQL语言中的ON DELETE CASCADE约束，将定义有外键的模型对象同时删除！（该操作为当前Django版本的默认操作！）</li><li><code>PROTECT:</code>阻止上面的删除操作，但是弹出ProtectedError异常</li><li><code>SET_NULL：</code>将外键字段设为null，只有当字段设置了null=True时，方可使用该值。</li><li><code>SET_DEFAULT:</code>将外键字段设为默认值。只有当字段设置了default参数时，方可使用。</li><li><code>DO_NOTHING：</code>什么也不做。</li><li><code>SET()：</code>设置为一个传递给SET()的值或者一个回调函数的返回值。注意大小写。<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings</span><br><span class="line"><span class="hljs-keyword">from</span> django.contrib.auth <span class="hljs-keyword">import</span> get_user_model</span><br><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sentinel_user</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> get_user_model().objects.get_or_create(username=<span class="hljs-string">'deleted'</span>)[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    user = models.ForeignKey(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.SET(get_sentinel_user),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li></ul><p><strong>limit_choices_to</strong><br>该参数用于限制外键所能关联的对象，只能用于Django的ModelForm（Django的表单模块）和admin后台，对其它场合无限制功能。其值可以是一个字典、Q对象或者一个返回字典或Q对象的函数调用，如下例所示：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">staff_member = models.ForeignKey(</span><br><span class="line">    User,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    limit_choices_to=&#123;<span class="hljs-string">'is_staff'</span>: <span class="hljs-literal">True</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样定义，则ModelForm的staff_member字段列表中，只会出现那些is_staff=True的Users对象，这一功能对于admin后台非常有用。</p><p>可以参考下面的方式，使用函数调用：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">limit_pub_date_choices</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">'pub_date__lte'</span>: datetime.date.utcnow()&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># ...</span></span><br><span class="line">limit_choices_to = limit_pub_date_choices</span><br><span class="line"><span class="hljs-comment"># ...</span></span><br></pre></td></tr></table></figure><p><strong>related_name</strong></p><p>用于关联对象反向引用模型的名称。以前面车和工厂的例子解释，就是从工厂反向关联到车的关系名称。</p><p>通常情况下，这个参数我们可以不设置，Django会默认以模型的小写加上_set作为反向关联名，比如对于工厂就是car_set，如果你觉得car_set还不够直观，可以如下定义：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    manufacturer = models.ForeignKey(</span><br><span class="line">        <span class="hljs-string">'production.Manufacturer'</span>,      </span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="hljs-string">'car_producted_by_this_manufacturer'</span>,  <span class="hljs-comment"># 看这里！！</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>也许我定义了一个蹩脚的词，但表达的意思很清楚。以后从工厂对象反向关联到它所生产的汽车，就可以使用<code>maufacturer.car_producted_by_this_manufacturer</code>了。</p><p>如果你不想为外键设置一个反向关联名称，可以将这个参数设置为“+”或者以“+”结尾，如下所示：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user = models.ForeignKey(</span><br><span class="line">     User,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    related_name=<span class="hljs-string">'+'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>related_query_name</strong><br>反向关联查询名。用于从目标模型反向过滤模型对象的名称。（过滤和查询在后续章节会介绍）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tag</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    article = models.ForeignKey(</span><br><span class="line">        Article,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="hljs-string">"tags"</span>,</span><br><span class="line">        related_query_name=<span class="hljs-string">"tag"</span>,       <span class="hljs-comment"># 注意这一行</span></span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="hljs-number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 现在可以使用‘tag’作为查询名了</span></span><br><span class="line">Article.objects.filter(tag__name=<span class="hljs-string">"important"</span>)</span><br></pre></td></tr></table></figure><p><strong>to_field</strong><br>默认情况下，外键都是关联到被关联对象的主键上（一般为id）。如果指定这个参数，可以关联到指定的字段上，但是该字段必须具有<code>unique=True</code>属性，也就是具有唯一属性。</p><p><strong>db_constraint</strong><br>默认情况下，这个参数被设为True，表示遵循数据库约束，这也是大多数情况下你的选择。如果设为False，那么将无法保证数据的完整性和合法性。在下面的场景中，你可能需要将它设置为False：</p><ul><li>有历史遗留的不合法数据，没办法的选择</li><li>你正在分割数据表</li></ul><p><strong>swappable</strong><br>控制迁移框架的动作，如果当前外键指向一个可交换的模型。使用场景非常稀少，通常请将该参数保持默认的True。</p><h2 id="多对多（ManyToManyField）"><a href="#多对多（ManyToManyField）" class="headerlink" title="多对多（ManyToManyField）"></a><strong>多对多（ManyToManyField）</strong></h2><p>多对多关系在数据库中也是非常常见的关系类型。比如一本书可以有好几个作者，一个作者也可以写好几本书。多对多的字段可以定义在任何的一方，请尽量定义在符合人们思维习惯的一方，但不要同时都定义。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManyToManyField</span><span class="hljs-params">(to, **options)</span>[<span class="hljs-title">source</span>]</span></span><br></pre></td></tr></table></figure><p>多对多关系需要一个位置参数：关联的对象模型。它的用法和外键多对一基本类似。</p><p>在数据库后台，Django实际上会额外创建一张用于体现多对多关系的中间表。默认情况下，该表的名称是“多对多字段名+关联对象模型名+一个独一无二的哈希码”，例如‘author_books_9cdf4’，当然你也可以通过db_table选项，自定义表名。</p><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h3><p><strong>related_name</strong><br>参考外键的相同参数。</p><p><strong>related_query_name</strong><br>参考外键的相同参数。</p><p><strong>limit_choices_to</strong><br>参考外键的相同参数。但是对于使用through参数自定义中间表的多对多字段无效。</p><p><strong>symmetrical</strong><br>默认情况下，Django中的多对多关系是对称的。看下面的例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    friends = models.ManyToManyField(<span class="hljs-string">"self"</span>)</span><br></pre></td></tr></table></figure><p>Django认为，如果我是你的朋友，那么你也是我的朋友，这是一种对称关系，Django不会为<code>Person模型</code>添加<code>person_set</code>属性用于反向关联。如果你不想使用这种对称关系，可以将<code>symmetrical</code>设置为<code>False</code>，这将强制<code>Django</code>为反向关联添加描述符。</p><p><strong>through（定义中间表）</strong><br>如果你想自定义多对多关系的那张额外的关联表，可以使用这个参数！参数的值为一个中间模型。</p><p>最常见的使用场景是你需要为多对多关系添加额外的数据，比如两个人建立QQ好友的时间。</p><p>通常情况下，这张表在数据库内的结构是这个样子的：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中间表的id列....模型对象的id列.....被关联对象的id列</span><br><span class="line"><span class="hljs-comment"># 各行数据</span></span><br></pre></td></tr></table></figure><p>如果自定义中间表并添加时间字段，则在数据库内的表结构如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中间表的id列....模型对象的id列.....被关联对象的id列.....时间对象列</span><br><span class="line"><span class="hljs-comment"># 各行数据</span></span><br></pre></td></tr></table></figure><p>看下面的例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="hljs-number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="hljs-number">128</span>)</span><br><span class="line">    members = models.ManyToManyField(</span><br><span class="line">        Person,</span><br><span class="line">        through=<span class="hljs-string">'Membership'</span>,       <span class="hljs-comment">## 自定义中间表</span></span><br><span class="line">        through_fields=(<span class="hljs-string">'group'</span>, <span class="hljs-string">'person'</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Membership</span><span class="hljs-params">(models.Model)</span>:</span>  <span class="hljs-comment"># 这就是具体的中间表模型</span></span><br><span class="line">    group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br><span class="line">    person = models.ForeignKey(Person, on_delete=models.CASCADE)</span><br><span class="line">    inviter = models.ForeignKey(</span><br><span class="line">        Person,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="hljs-string">"membership_invites"</span>,</span><br><span class="line">    )</span><br><span class="line">    invite_reason = models.CharField(max_length=<span class="hljs-number">64</span>)</span><br></pre></td></tr></table></figure><p>上面的代码中，通过<code>class Membership(models.Model)</code>定义了一个新的模型，用来保存<code>Person</code>和<code>Group</code>模型的多对多关系，并且同时增加了‘邀请人’和‘邀请原因’的字段。<br><strong>through参数在某些使用场景中是必须的，至关重要，请务必掌握！</strong></p><p><strong>through_fields</strong><br>接着上面的例子。Membership模型中包含两个关联Person的外键，Django无法确定到底使用哪个作为和Group关联的对象。所以，在这个例子中，必须显式的指定through_fields参数，用于定义关系。</p><p><code>through_fields</code>参数接收一个二元元组<code>(&#39;field1&#39;, &#39;field2&#39;)</code>，<code>field1</code>是指向定义有多对多关系的模型的外键字段的名称，这里是<code>Membership</code>中的‘group’字段（注意大小写），另外一个则是指向目标模型的外键字段的名称，这里是<code>Membership</code>中的‘person’，而不是‘inviter’。</p><p>再通俗的说，就是<code>through_fields</code>参数指定从中间表模型<code>Membership</code>中选择哪两个字段，作为关系连接字段。</p><p><strong>db_table</strong><br>设置中间表的名称。不指定的话，则使用默认值。</p><p><strong>db_constraint</strong><br>参考外键的相同参数。</p><p><strong>swappable</strong><br>参考外键的相同参数。</p><p><strong>ManyToManyField多对多字段不支持Django内置的validators验证功能。</strong></p><p><strong>null参数对ManyToManyField多对多字段无效！设置null=True毫无意义</strong></p><h2 id="一对一（OneToOneField）"><a href="#一对一（OneToOneField）" class="headerlink" title="一对一（OneToOneField）"></a><strong>一对一（OneToOneField）</strong></h2><p>一对一关系类型的定义如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneToOneField</span><span class="hljs-params">(to, on_delete, parent_link=False, **options)</span>[<span class="hljs-title">source</span>]</span></span><br></pre></td></tr></table></figure><p>从概念上讲，一对一关系非常类似具有<code>unique=True</code>属性的外键关系，但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如，Django自带auth模块的User用户表，如果你想在自己的项目里创建用户模型，又想方便的使用Django的认证功能，那么一个比较好的方案就是在你的用户模型里，使用一对一关系，添加一个与auth模块User模型的关联字段。</p><p>该关系的第一位置参数为关联的模型，其用法和前面的多对一外键一样。</p><p>如果你没有给一对一关系设置<code>related_name</code>参数，Django将使用当前模型的小写名作为默认值。</p><p>看下面的例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings</span><br><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 两个字段都使用一对一关联到了Django内置的auth模块中的User模型</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpecialUser</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    user = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">    )</span><br><span class="line">    supervisor = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.CASCADE,</span><br><span class="line">        related_name=<span class="hljs-string">'supervisor_of'</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这样下来，你的User模型将拥有下面的属性：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; user = User.objects.get(pk=1)</span><br><span class="line">&gt;&gt;&gt; hasattr(user, <span class="hljs-string">'myspecialuser'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; hasattr(user, <span class="hljs-string">'supervisor_of'</span>)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>OneToOneField一对一关系拥有和多对一外键关系一样的额外可选参数，只是多了一个parent_link参数。</p><p><strong>跨模块的模型：</strong></p><p>有时候，我们关联的模型并不在当前模型的文件内，没关系，就像我们导入第三方库一样的从别的模块内导入进来就好，如下例所示：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"><span class="hljs-keyword">from</span> geography.models <span class="hljs-keyword">import</span> ZipCode</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Restaurant</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># ...</span></span><br><span class="line">    zip_code = models.ForeignKey(</span><br><span class="line">        ZipCode,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">        blank=<span class="hljs-literal">True</span>,</span><br><span class="line">        null=<span class="hljs-literal">True</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>模型与字段</title>
    <link href="http://yoursite.com/2019/11/02/%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AD%97%E6%AE%B5/"/>
    <id>http://yoursite.com/2019/11/02/模型与字段/</id>
    <published>2019-11-01T18:24:47.000Z</published>
    <updated>2019-11-01T18:28:14.877Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><a id="more"></a><h2 id="模型和字段"><a href="#模型和字段" class="headerlink" title="模型和字段"></a>模型和字段</h2><p>一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。</p><p>基本的原则如下：</p><ul><li>每个模型在Django中的存在形式为一个Python类</li><li>每个模型都是django.db.models.Model的子类</li><li>模型的每个字段（属性）代表数据表的某一列</li><li>Django将自动为你生成数据库访问API</li></ul><p><strong>简单示例：</strong><br>下面的模型定义了一个“人”，它具有first_name和last_name字段：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="hljs-number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="hljs-number">30</span>)</span><br></pre></td></tr></table></figure><p>上面的代码，相当于下面的原生SQL语句：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE myapp_person (</span><br><span class="line">    <span class="hljs-string">"id"</span> serial NOT NULL PRIMARY KEY,</span><br><span class="line">    <span class="hljs-string">"first_name"</span> varchar(<span class="hljs-number">30</span>) NOT NULL,</span><br><span class="line">    <span class="hljs-string">"last_name"</span> varchar(<span class="hljs-number">30</span>) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>表名myapp_person由Django自动生成，默认格式为“项目名称+下划线+小写类名”，你可以重写这个规则。</li><li>Django默认自动创建自增主键id，当然，你也可以自己指定主键。</li><li>上面的SQL语句基于PostgreSQL语法。</li></ul><p>建了模型之后，在使用它之前，你需要先在<strong>settings</strong>文件中的<strong>INSTALLED_APPS</strong>处，注册<strong>models.py</strong>文件所在的myapp。看清楚了，是注册app，不是模型，也不是models.py。如果你以前写过模型，可能已经做过这一步工作，可跳过。</p><p>当你每次对模型进行增、删、修改时，请务必执行命令<strong>python manage.py migrate</strong>，让操作实际应用到数据库上。这里可以选择在执行migrate之前，先执行<strong>ython manage.py makemigrations</strong>让修改动作保存到记录文件中，方便github等工具的使用。</p><hr><h3 id="模型字段fields"><a href="#模型字段fields" class="headerlink" title="模型字段fields"></a><strong>模型字段fields</strong></h3><p>字段是模型中最重要的内容之一，也是唯一必须的部分。字段在Python中表现为一个类属性，体现了数据表中的一个列。请不要使用<strong>clean</strong>、<strong>save</strong>、<strong>delete</strong>等Django内置的模型API名字，防止命名冲突。下面是一个展示，注意字段的写法：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Musician</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="hljs-number">50</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="hljs-number">50</span>)</span><br><span class="line">    instrument = models.CharField(max_length=<span class="hljs-number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Album</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)</span><br><span class="line">    name = models.CharField(max_length=<span class="hljs-number">100</span>)</span><br><span class="line">    release_date = models.DateField()</span><br><span class="line">    num_stars = models.IntegerField()</span><br></pre></td></tr></table></figure><h3 id="字段命名约束"><a href="#字段命名约束" class="headerlink" title="字段命名约束"></a><strong>字段命名约束</strong></h3><p><strong>Django不允许下面两种字段名：</strong></p><ul><li>与Python关键字冲突。这会导致语法错误。例如：<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line"><span class="hljs-keyword">pass</span> = models.IntegerField() <span class="hljs-comment"># 'pass'是Python保留字！</span></span><br></pre></td></tr></table></figure></li><li>字段名中不能有两个以上下划线在一起，因为两个下划线是Django的查询语法。例如：<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">foo__bar = models.IntegerField() <span class="hljs-comment"># 'foo__bar' 有两个下划线在一起!</span></span><br></pre></td></tr></table></figure>由于你可以自定义表名、列名，上面的规则可能被绕开，但是请养成良好的习惯，一定不要那么起名。SQL语言的join、where和select等保留字可以作为字段名，因为Django对它们都进行了转义。</li></ul><hr><h3 id="常用字段类型"><a href="#常用字段类型" class="headerlink" title="常用字段类型"></a><strong>常用字段类型</strong></h3><p><strong>字段类型的作用：</strong></p><ul><li>决定数据库中对应列的数据类型(例如：INTEGER, VARCHAR, TEXT)</li><li>HTML中对应的表单标签的类型，例如<code>&lt;input type=&#39;&#39;text&#39;&#39; /&gt;</code></li><li>在admin后台和自动生成的表单中最小的数据验证需求</li></ul><p>Django内置了许多字段类型，它们都位于django.db.models中，例如models.CharField。这些类型基本满足需求，如果还不够，你也可以自定义字段。</p><p>下表列出了所有Django内置的字段类型，但不包括关系字段类型（字段名采用驼峰命名法，初学者请一定要注意）：</p><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AutoField</td><td align="left">一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id=models.AutoField(primary_key=True</code>)，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为primary_key=True。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td></tr><tr><td align="left">BigAutoField</td><td align="left">1.10新增)64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td></tr><tr><td align="left">BigIntegerField</td><td align="left">64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个textinput标签。</td></tr><tr><td align="left">BinaryField</td><td align="left">二进制数据类型。使用受限，少用。</td></tr><tr><td align="left">BooleanField</td><td align="left">布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果要接收null值，请使用NullBooleanField。</td></tr><tr><td align="left">CharField</td><td align="left">字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是input text。最常用的filed，没有之一！</td></tr><tr><td align="left">CommaSeparatedIntegerField</td><td align="left">逗号分隔的整数类型。必须接收一个max_length参数。常用于表示较大的金额数目，例如1,000,000元</td></tr><tr><td align="left">DateField</td><td align="left">class DateField(auto_now=False, auto_now_add=False, **options)日期类型。一个Python中的datetime.date的实例。在HTML中表现为TextInput标签。在admin后台中，Django会帮你自动添加一个JS的日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） auto_now:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。auto_now_add：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了editable=False和blank=True属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td></tr><tr><td align="left">DateTimeField</td><td align="left">日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td></tr><tr><td align="left">DecimalField</td><td align="left">固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数max_digits：最大的位数，必须大于或等于小数点位数 。decimal_places：小数点位数，精度。 当localize=False时，它在HTML表现为NumberInput标签，否则是text类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：models.DecimalField(…, max_digits=5, decimal_places=2)。</td></tr><tr><td align="left">DurationField</td><td align="left">持续时间类型。存储一定期间的时间长度。类似Python中的timedelta。在不同的数据库实现中有不同的表示方法。常用于进行时间之间的加减运算。但是小心了，这里有坑，PostgreSQL等数据库之间有兼容性问题！</td></tr><tr><td align="left">EmailField</td><td align="left">邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用DJango内置的EmailValidator进行邮箱地址合法性验证。</td></tr><tr><td align="left">FileField</td><td align="left"><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td></tr><tr><td align="left">FilePathField</td><td align="left">文件路径类型，后面单独介绍</td></tr><tr><td align="left">FloatField</td><td align="left">浮点数类型，参考整数类型</td></tr><tr><td align="left">ImageField</td><td align="left">图像类型，后面单独介绍。</td></tr><tr><td align="left">IntegerField</td><td align="left">整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput标签。</td></tr><tr><td align="left">GenericIPAddressField</td><td align="left"><code>class GenericIPAddressField(protocol=&#39;both&#39;, unpack_ipv4=False, **options)[source]</code>,IPV4或者IPV6地址，字符串形式，例如192.0.2.30或者2a02:42fe::4在HTML中表现为TextInput标签。参数protocol默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td></tr><tr><td align="left">NullBooleanField</td><td align="left">类似布尔字段，只不过额外允许NULL作为选项之一。</td></tr><tr><td align="left">PositiveIntegerField</td><td align="left">正整数字段，包含0,最大2147483647。</td></tr><tr><td align="left">PositiveSmallIntegerField</td><td align="left">较小的正整数字段，从0到32767。</td></tr><tr><td align="left">SlugField</td><td align="left">slug是一个新闻行业的术语。一个slug就是一个某种东西的简短标签，包含字母、数字、下划线或者连接线，通常用于URLs中。可以设置max_length参数，默认为50。</td></tr><tr><td align="left">SmallIntegerField</td><td align="left">小整数，包含-32768到32767。</td></tr><tr><td align="left">TextField</td><td align="left">大量文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td></tr><tr><td align="left">TimeField</td><td align="left">时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td></tr><tr><td align="left">URLField</td><td align="left">一个用于保存URL地址的字符串类型，默认最大长度200。</td></tr><tr><td align="left">UUIDField</td><td align="left">用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品，后面有例子展示。</td></tr></tbody></table><hr><h3 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a><strong>FileField</strong></h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class FileField(upload_to=None, max_length=100, **options)[<span class="hljs-built_in">source</span>]</span><br></pre></td></tr></table></figure><p>上传文件字段（不能设置为主键）。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，可以通过max_length参数自定义。真实的文件是保存在服务器的文件系统内的。</p><p>重要参数upload_to用于设置上传地址的目录和文件名。如下例所示：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyModel(models.Model):</span><br><span class="line">    <span class="hljs-comment"># 文件被传至`MEDIA_ROOT/uploads`目录，MEDIA_ROOT由你在settings文件中设置</span></span><br><span class="line">    upload = models.FileField(upload_to=<span class="hljs-string">'uploads/'</span>)</span><br><span class="line">    <span class="hljs-comment"># 或者被传到`MEDIA_ROOT/uploads/2019/10/25`目录，增加了一个时间划分</span></span><br><span class="line">    upload = models.FileField(upload_to=<span class="hljs-string">'uploads/%Y/%m/%d/'</span>)</span><br></pre></td></tr></table></figure><p>upload_to参数也可以接收一个回调函数，该函数返回具体的路径字符串，如下例：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def user_directory_path(instance, filename):</span><br><span class="line">    <span class="hljs-comment">#文件上传到MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt;目录中</span></span><br><span class="line">    <span class="hljs-built_in">return</span> <span class="hljs-string">'user_&#123;0&#125;/&#123;1&#125;'</span>.format(instance.user.id, filename)</span><br><span class="line"></span><br><span class="line">class MyModel(models.Model):</span><br><span class="line">    upload = models.FileField(upload_to=user_directory_path)</span><br></pre></td></tr></table></figure><p>例子中，<code>user_directory_path</code> 这种回调函数，必须接收两个参数，然后返回一个Unix风格的路径字符串。参数instace代表一个定义了FileField的模型的实例，说白了就是当前数据记录。filename是原本的文件名。</p><hr><h3 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a><strong>ImageField</strong></h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)[<span class="hljs-built_in">source</span>]</span><br></pre></td></tr></table></figure><p>用于保存图像文件的字段。其基本用法和特性与FileField一样，只不过多了两个属性height和width。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，可以通过max_length参数自定义。真实的图片是保存在服务器的文件系统内的。</p><p>height_field参数：保存有图片高度信息的模型字段名。 width_field参数：保存有图片宽度信息的模型字段名。<strong>使用Django的ImageField需要提前安装pillow模块，pip install pillow即可。</strong></p><p>使用FileField或者ImageField字段的步骤：</p><ol><li>在settings文件中，配置MEDIA_ROOT，作为你上传文件在服务器中的基本路径（为了性能考虑，这些文件不会被储存在数据库中）。再配置个MEDIA_URL，作为公用URL，指向上传文件的基本路径。请确保Web服务器的用户账号对该目录具有写的权限。</li><li>添加FileField或者ImageField字段到你的模型中，定义好upload_to参数，文件最终会放在MEDIA_ROOT目录的“upload_to”子目录中。</li><li>所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。例如，假设你有一个ImageField字段，名叫mug_shot，那么在Django模板的HTML文件中，可以使用来获取该文件。其中的object用你具体的对象名称代替。</li><li>可以通过name和size属性，获取文件的名称和大小信息。</li></ol><p><strong>安全建议：</strong><br>无论你如何保存上传的文件，一定要注意他们的内容和格式，避免安全漏洞！务必对所有的上传文件进行安全检查，确保它们不出问题！如果你不加任何检查就盲目的让任何人上传文件到你的服务器文档根目录内，比如上传了一个CGI或者PHP脚本，很可能就会被访问的用户执行，这具有致命的危害。</p><hr><h3 id="FilePathField"><a href="#FilePathField" class="headerlink" title="FilePathField"></a><strong>FilePathField</strong></h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilePathField</span><span class="hljs-params">(path=None, match=None, recursive=False, max_length=<span class="hljs-number">100</span>, **options)</span>[<span class="hljs-title">source</span>]</span></span><br></pre></td></tr></table></figure><p>一种用来保存文件路径信息的字段。在数据表内以字符串的形式存在，默认最大长度100，可以通过max_length参数设置。<br><strong>它包含有下面的一些参数：</strong><br><code>path:</code>必须指定的参数。表示一个系统绝对路径。<br><code>match:</code>可选参数，一个正则表达式，用于过滤文件名。只匹配基本文件名，不匹配路径。例如<code>foo.*\.txt$</code>，只匹配文件名<code>foo23.txt</code>，不匹配<code>bar.txt</code>与<code>foo23.png</code>。<br><code>recursive:</code>可选参数，只能是True或者False。默认为False。决定是否包含子目录，也就是是否递归的意思。<br><code>allow_files:</code>可选参数，只能是True或者False。默认为True。决定是否应该将文件名包括在内。它和allow_folders其中，必须有一个为True。<br><code>allow_folders：</code>可选参数，只能是True或者False。默认为False。决定是否应该将目录名包括在内。<br>比如：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilePathField(path=<span class="hljs-string">"/home/images"</span>, match=<span class="hljs-string">"foo.*"</span>, recursive=<span class="hljs-literal">True</span>)</span><br></pre></td></tr></table></figure><p>它只匹配<code>/home/images/foo.png</code>，但不匹配<code>/home/images/foo/bar.png</code>，因为默认情况，只匹配文件名，而不管路径是怎么样的。</p><hr><h3 id="UUIDField"><a href="#UUIDField" class="headerlink" title="UUIDField"></a><strong>UUIDField</strong></h3><p>数据库无法自己生成uuid，因此需要如下使用default参数：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> uuid     <span class="hljs-comment"># Python的内置模块</span></span><br><span class="line"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUUIDModel</span><span class="hljs-params">(models.Model)</span>:</span></span><br><span class="line">    id = models.UUIDField(primary_key=<span class="hljs-literal">True</span>, default=uuid.uuid4, editable=<span class="hljs-literal">False</span>)</span><br><span class="line">    <span class="hljs-comment"># 其它字段</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django：模型层</title>
    <link href="http://yoursite.com/2019/10/25/%E6%A8%A1%E5%9E%8B%E5%B1%82/"/>
    <id>http://yoursite.com/2019/10/25/模型层/</id>
    <published>2019-10-24T17:19:00.000Z</published>
    <updated>2019-11-01T18:28:36.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你要开发一个好的网站或网络应用，你就必需了解经典的软件开发所遵循的MVC设计模式。Django作为最优秀的基于Python语言的网站开发框架，当然也遵循了这种设计模式。</p></blockquote><a id="more"></a><h1 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h1><p>在MVC或者说MTV设计模式中，模型（M）代表对数据库的操作。那么如何操作数据库呢？</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 使用第三库pymysql，创建连接</span></span><br><span class="line">conn = pymysql.connect(host=<span class="hljs-string">'127.0.0.1'</span>, port=<span class="hljs-number">3306</span>, user=<span class="hljs-string">'root'</span>, passwd=<span class="hljs-string">'123456'</span>, db=<span class="hljs-string">'test'</span>)</span><br><span class="line"><span class="hljs-comment"># 创建游标</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="hljs-comment"># 执行SQL，并返回收影响行数</span></span><br><span class="line">effect_row = cursor.execute(<span class="hljs-string">"insert into host (hostname,port,ip) values('ubuntu','22','10.0.0.2');"</span>)</span><br><span class="line"><span class="hljs-comment"># 提交，不然无法保存新建或者修改的数据</span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="hljs-comment"># 关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="hljs-comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>但是，如果你有很多的数据库操作，并且你的Python程序员不是专业的DBA，写的SQL语句很烂，甚至经常写错，怎么办？聪明的人想出了一个办法：用Python语法来写，然后使用一个中间工具将Python代码翻译成原生的SQL语句，这样你总不会写错了吧？这个中间工具就是所谓的<strong>ORM</strong>（对象关系映射）！ORM将一个Python的对象映射为数据库中的一张关系表。它将SQL封装起来，程序员不再需要关心数据库的具体操作，只需要专注于自己本身代码和业务逻辑的实现。<br><img src="http://static.zybuluo.com/feixuelove1009/k1s4q20bnmdy1pbn0lxie992/image.png" alt="ORM"></p><p><strong>Django的ORM系统体现在框架内就是模型层。</strong>想要理解<strong>模型层</strong>的概念，关键在于理解用Python代码的方式来定义数据库表的做法！一个Python的类，就是一个模型，代表数据库中的一张数据表！Django奉行Python优先的原则，一切基于Python代码的交流，完全封装SQL内部细节。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果你要开发一个好的网站或网络应用，你就必需了解经典的软件开发所遵循的MVC设计模式。Django作为最优秀的基于Python语言的网站开发框架，当然也遵循了这种设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国网络安全法</title>
    <link href="http://yoursite.com/2019/10/08/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/08/中华人民共和国网络安全法/</id>
    <published>2019-10-08T13:46:09.000Z</published>
    <updated>2019-10-23T16:41:16.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《<strong>中华人民共和国网络安全法</strong>》是为保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展制定。由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起施行。</p></blockquote><a id="more"></a><h1 id="中华人民共和国网络安全法"><a href="#中华人民共和国网络安全法" class="headerlink" title="中华人民共和国网络安全法"></a>中华人民共和国网络安全法</h1><p>中文名：<strong>中华人民共和国网络安全法</strong></p><p>外文名：People’s Republic of China Network Security Law</p><p>发布机构：全国人民代表大会常务委员会</p><p>发布日期：2016年11月7日</p><p>实施日期：2017年6月1日</p><p>​    <a href="#1">第一章  总    则</a></p><p>​    <a href="#2">第二章  网络安全支持与促进</a></p><p>​    <a href="#3">第三章  网络运行安全</a></p><p>​    <a href="#4">第一节  一般规定</a></p><p>​    <a href="#5">第二节  关键信息基础设施的运行安全</a></p><p>​    <a href="#6">第四章  网络信息安全</a></p><p>​    <a href="#7">第五章  监测预警与应急处置</a></p><p>​    <a href="#8">第六章  法律责任</a></p><p>​    <a href="#9">第七章  附    则</a></p><span id="1"><h3 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章  总    则"></a>第一章  总    则</h3><p><strong>第一条</strong>  为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。</p><p><strong>第二条</strong>  在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。</p><p><strong>第三条</strong>  国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。</p><p><strong>第四条</strong>  国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。</p><p><strong>第五条</strong>  国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。</p><p><strong>第六条</strong>  国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。</p><p><strong>第七条</strong>  国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。</p><p><strong>第八条</strong>  国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。</p><p>县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。</p><p><strong>第九条</strong>  网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。</p><p><strong>第十条</strong>  建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。</p><p><strong>第十一条</strong>  网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。</p><p><strong>第十二条</strong>  国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。</p><p>任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。</p><p><strong>第十三条</strong>  国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。</p><p><strong>第十四条</strong>  任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。</p><p>有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。<br><span id="2"></span></p><h3 id="第二章-网络安全支持与促进"><a href="#第二章-网络安全支持与促进" class="headerlink" title="第二章  网络安全支持与促进"></a>第二章  网络安全支持与促进</h3><p><strong>第十五条</strong>  国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。</p><p>国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。</p><p><strong>第十六条</strong>  国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。</p><p><strong>第十七条</strong>  国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。</p><p><strong>第十八条</strong>  国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。</p><p>国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。</p><p><strong>第十九条</strong>  各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。</p><p>大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。</p><p><strong>第二十条</strong>  国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。<br><span id="3"></span></p><h3 id="第三章-网络运行安全"><a href="#第三章-网络运行安全" class="headerlink" title="第三章  网络运行安全"></a>第三章  网络运行安全</h3><span id="4"><h4 id="第一节-一般规定"><a href="#第一节-一般规定" class="headerlink" title="第一节 一般规定"></a>第一节 一般规定</h4><p><strong>第二十一条</strong>  国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：</p><p>（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；</p><p>（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；</p><p>（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；</p><p>（四）采取数据分类、重要数据备份和加密等措施；</p><p>（五）法律、行政法规规定的其他义务。</p><p><strong>第二十二条</strong>  网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><p>网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。</p><p>网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。</p><p><strong>第二十三条</strong>  网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。</p><p><strong>第二十四条</strong>  网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。</p><p>国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。</p><p><strong>第二十五条</strong>  网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。</p><p><strong>第二十六条</strong>  开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。</p><p><strong>第二十七条</strong>  任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。</p><p><strong>第二十八条</strong>  网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。</p><p><strong>第二十九条</strong>  国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。</p><p>有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。</p><p><strong>第三十条</strong>  网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。<br><span id="5"></span></p><h4 id="第二节-关键信息基础设施的运行安全"><a href="#第二节-关键信息基础设施的运行安全" class="headerlink" title="第二节 关键信息基础设施的运行安全"></a>第二节 关键信息基础设施的运行安全</h4><p><strong>第三十一条</strong>  国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。</p><p>国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。</p><p><strong>第三十二条</strong>  按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。</p><p><strong>第三十三条</strong>  建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。</p><p><strong>第三十四条</strong>  除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务：</p><p>（一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查；</p><p>（二）定期对从业人员进行网络安全教育、技术培训和技能考核；</p><p>（三）对重要系统和数据库进行容灾备份；</p><p>（四）制定网络安全事件应急预案，并定期进行演练；</p><p>（五）法律、行政法规规定的其他义务。</p><p><strong>第三十五条</strong>  关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。</p><p><strong>第三十六条</strong>  关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。</p><p><strong>第三十七条</strong>  关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。</p><p><strong>第三十八条</strong>  关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。</p><p><strong>第三十九条</strong>  国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施：</p><p>（一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估；</p><p>（二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力；</p><p>（三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享；</p><p>（四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。<br><span id="6"></span></p><h3 id="第四章-网络信息安全"><a href="#第四章-网络信息安全" class="headerlink" title="第四章  网络信息安全"></a>第四章  网络信息安全</h3><p><strong>第四十条</strong>  网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。</p><p><strong>第四十一条</strong>  网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。</p><p>网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。</p><p><strong>第四十二条</strong>  网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。</p><p>网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><p><strong>第四十三条</strong>  个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。</p><p><strong>第四十四条</strong>  任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。</p><p><strong>第四十五条</strong>  依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。</p><p><strong>第四十六条</strong>  任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。</p><p><strong>第四十七条</strong>  网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。</p><p><strong>第四十八条</strong>  任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。</p><p>电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。</p><p><strong>第四十九条</strong>  网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。</p><p>网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。</p><p><strong>第五十条</strong>  国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。<br><span id="7"></span></p><h3 id="第五章-监测预警与应急处置"><a href="#第五章-监测预警与应急处置" class="headerlink" title="第五章  监测预警与应急处置"></a>第五章  监测预警与应急处置</h3><p><strong>第五十一条</strong>  国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。</p><p><strong>第五十二条</strong>  负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。</p><p><strong>第五十三条</strong>  国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。</p><p>负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。</p><p>网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。</p><p><strong>第五十四条</strong>  网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施：</p><p>（一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测；</p><p>（二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度；</p><p>（三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。</p><p><strong>第五十五条</strong>  发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。</p><p><strong>第五十六条</strong>  省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。</p><p><strong>第五十七条</strong>  因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。</p><p><strong>第五十八条</strong> 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。<br><span id="8"></span></p><h3 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章  法律责任"></a>第六章  法律责任</h3><p><strong>第五十九条</strong>  网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p><p>关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p><p><strong>第六十条</strong>  违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款：</p><p>（一）设置恶意程序的；</p><p>（二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的；</p><p>（三）擅自终止为其产品、服务提供安全维护的。</p><p><strong>第六十一条</strong>  网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十二条</strong>  违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。</p><p><strong>第六十三条</strong>  违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。</p><p>单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</p><p>违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。</p><p><strong>第六十四条</strong>  网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。</p><p>违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。</p><p><strong>第六十五条</strong>  关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十六条</strong>  关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十七条</strong>  违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。</p><p>单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</p><p><strong>第六十八条</strong>  网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p>电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。</p><p><strong>第六十九条</strong>  网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款：</p><p>（一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的；</p><p>（二）拒绝、阻碍有关部门依法实施的监督检查的；</p><p>（三）拒不向公安机关、国家安全机关提供技术支持和协助的。</p><p><strong>第七十条</strong>  发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。</p><p><strong>第七十一条</strong>  有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。</p><p><strong>第七十二条</strong>  国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。</p><p><strong>第七十三条</strong>  网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。</p><p>网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。</p><p><strong>第七十四条</strong>  违反本法规定，给他人造成损害的，依法承担民事责任。</p><p>违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</p><p><strong>第七十五条</strong>  境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。<br><span id="9"></span></p><h3 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章  附    则"></a>第七章  附    则</h3><p><strong>第七十六条</strong>  本法下列用语的含义：</p><p>（一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。</p><p>（二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。</p><p>（三）网络运营者，是指网络的所有者、管理者和网络服务提供者。</p><p>（四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。</p><p>（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。</p><p><strong>第七十七条</strong>  存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。</p><p><strong>第七十八条</strong>  军事网络的安全保护，由中央军事委员会另行规定。</p><p><strong>第七十九条</strong>  本法自2017年6月1日起施行。</p></span></span>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《&lt;strong&gt;中华人民共和国网络安全法&lt;/strong&gt;》是为保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展制定。由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起施行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="法律" scheme="http://yoursite.com/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="http://yoursite.com/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
</feed>
